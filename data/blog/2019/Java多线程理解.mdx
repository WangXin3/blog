---
title: Java多线程理解
date: '2019-05-02'
tags: ['Java', 'Thread']
draft: false
summary: '多线程'
---

#### 实现多线程的两种方式？

- 继承 Thread类，重写run方法，将需要线程执行的逻辑放入。
- 实现Runnable接口，实现run方法，将需要线程执行的逻辑放入。

#### 继承Thread类和实现Runnable接口有什么区别？

- Thread只能通过继承来实现多线程，但是继承只能单继承，从而导致扩展性差。
- Runnable是一个接口，接口是可以多实现的，从而解决了扩展性差的问题。
- Thread不能资源共享。（适合用于N个线程执行N个任务（一对一），互不干扰）
- Runnable可以资源共享。（适合多个线程执行一个任务）

#### 线程的五大状态？

- 新建状态：new出一个线程，但未调用start方法。
- 就绪状态：调用start()方法，进入就绪状态。（有cpu执行资格，等待获取cpu执行权限）
- 运行状态：调用run()方法。（有cpu执行资格和权限）
- 阻塞状态：调用了sleep()方法休眠，或者wait()方法。（释放cpu执行资格和权限）
  - 等待阻塞：运行态线程执行wait()方法，jvm会把该线程放入等待队列。
  - 同步阻塞：运行态线程在获取同步锁时，该锁被占用，则该线程放入锁池中。
  - 其他阻塞：运行态线程执行sleep()或join()方法，或者发生I/O请求，JVM会把该线程置为阻塞状态。当这些sleep或join方法、I/O请求结束后，线程重新转入就绪状态。
- 结束状态：run()方法正常退出而死亡，未捕获异常导致死亡。

#### 线程同步？

- synchronized（同步代码块）：只有线程获得到实例锁才能进入执行方法，否则只能等待。
- Lock（接口）：java5.0的新特性；功能比synchronized更加强大。

#### sleep()、wait()、yield()、join()的区别?

- sleep()会放弃CPU执行权，不会释放锁。使程序暂停执行，暂停结束之后直接进入就绪状态。
- wait()会放弃CPU执行权，也会释放锁，如果需要运行，需要被其他线程notify()或notifyAll() 唤醒，并且和其他线程去竞争锁。
- yield()暂停当前正在执行的线程对象。
  - yield()只是使当前线程重新回到就绪状态，所以执行yield()方法的线程有可能在进入到就绪状态后马上又被执行。
  - yield()只能使同优先级或更高优先级的线程有执行的机会。
- join()等待该线程终止。当主线程运行过程中遇到子线程调用join()方法，则主线程等待子线程完成之后，再执行下面流程。
